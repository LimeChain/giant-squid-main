type Account @entity {
    id: ID!
    publicKey: ID! @index
    transfers: [Transfer!] @derivedFrom(field: "account")
    rewards: [StakingReward!] @derivedFrom(field: "account")

    identity: Identity @derivedFrom(field: "account")
    sub: IdentitySub @derivedFrom(field: "account")

    stashOf: Staker @derivedFrom(field: "stash")
    controllerOf: Staker @derivedFrom(field: "controller")
}

enum TransferDirection {
    From
    To
}

# entity for linking account and transfer
type Transfer @entity {
    id: ID!
    transfer: NativeTransfer
    account: Account!
    direction: TransferDirection
}

type NativeTransfer @entity {
    id: ID!
    blockNumber: Int! @index
    timestamp: DateTime! @index
    extrinsicHash: String @index
    from: Account!
    to: Account!
    amount: BigInt! @index
    success: Boolean!
}

type IdentityAdditionalField {
    name: String
    value: String
}

enum Judgement {
    Unknown
    FeePaid
    Reasonable
    KnownGood
    OutOfDate
    LowQuality
    Erroneous
}

type Identity @entity {
    id: ID!
    account: Account! @unique
    judgement: Judgement!
    subs: [IdentitySub!] @derivedFrom(field: "super")
    additional: [IdentityAdditionalField!]
    display: String
    legal: String
    web: String
    riot: String
    email: String
    pgpFingerprint: String
    image: String
    twitter: String
    isKilled: Boolean!
}

type IdentitySub @entity {
    id: ID!
    super: Identity
    account: Account! @unique
    name: String
}

type StakingReward @entity {
    id: ID!
    timestamp: DateTime!
    blockNumber: Int! @index
    extrinsicHash: String @index
    account: Account!
    amount: BigInt!
    era: Int
    validatorId: ID
    validator: StakingEraValidator
    staker: Staker!
}

type StakingSlash @entity {
    id: ID!
    timestamp: DateTime!
    blockNumber: Int! @index
    extrinsicHash: String @index
    account: Account!
    amount: BigInt!
    staker: Staker!
}

type StakingBond @entity {
    id: ID!
    timestamp: DateTime!
    blockNumber: Int! @index
    extrinsicHash: String @index
    account: Account!
    amount: BigInt!
    staker: Staker!
}

type StakingUnlockChunk @entity {
    id: ID!
    timestamp: DateTime!
    blockNumber: Int! @index
    staker: Staker!
    lockedUntilEra: Int!
    amount: BigInt!
    withdrawn: Boolean!
}

enum StakingRole {
    Validator
    Nominator
    Idle
    Unknown
}

type ValidatorData {
    commission: Float!
    blocked: Boolean!
}

type NominatorData {
    targets: [String!]!
}

union StakingData = ValidatorData | NominatorData

enum PayeeType {
    Staked
    Stash
    Controller
    Account
    None
    Unknown
}

type Staker @entity {
    id: ID! #stash Id
    stash: Account! @unique
    controller: Account @unique

    payeeType: PayeeType!
    payee: Account

    activeBond: BigInt!
    totalBond: BigInt!

    totalReward: BigInt!
    totalSlash: BigInt!

    role: StakingRole!
    data: StakingData

    unlocking: [StakingUnlockChunk!] @derivedFrom(field: "staker")

    # history: [EraStaker!] @derivedFrom(field: "staker")
    rewards: [StakingReward!] @derivedFrom(field: "staker")
    slashes: [StakingSlash!] @derivedFrom(field: "staker")
    bonds: [StakingBond!] @derivedFrom(field: "staker")

    isKilled: Boolean!
}

enum StakingEraStatus {
    Planned
    Active
    Ended
}

type StakingEra @entity {
    id: ID!
    index: Int!
    status: StakingEraStatus!
    createdAt: Int!
    startedAt: Int
    endedAt: Int
    total: BigInt!
    validatorsCount: Int!
    nominatorsCount: Int!
    # stakers: [EraStaker] @derivedFrom(field: "era")
}

interface StakingEraStaker @query {
    id: ID! #era + stashId
    staker: Staker!
    era: StakingEra!
    bonded: BigInt!
    eraReward: BigInt!
    # eraSlash: BigInt!
}

type StakingEraValidator implements StakingEraStaker @entity {
    id: ID! #era + stashId
    staker: Staker!
    era: StakingEra!
    bonded: BigInt!
    totalBonded: BigInt!
    eraReward: BigInt!
    # eraSlash: BigInt!
    commission: Int
    nominators: [StakingEraNomination!] @derivedFrom(field: "validator")
}

type StakingEraNominator implements StakingEraStaker @entity {
    id: ID! #era + stashId
    staker: Staker!
    era: StakingEra!
    bonded: BigInt!
    eraReward: BigInt!
    # eraSlash: BigInt!
    validators: [StakingEraNomination!] @derivedFrom(field: "nominator")
}

type StakingEraNomination @entity {
    id: ID! #era + validatorId + nominatorId
    era: StakingEra!
    nominator: StakingEraNominator!
    validator: StakingEraValidator!
    vote: BigInt!
}
