type Account @entity {
    id: ID!
    publicKey: ID! @index
    transfers: [Transfer!] @derivedFrom(field: "account")
    rewards: [StakingReward!] @derivedFrom(field: "account")
    identity: Identity @derivedFrom(field: "account")
    sub: IdentitySub @derivedFrom(field: "account")
}

enum TransferDirection {
    From
    To
}

# entity for linking account and transfer
type Transfer @entity {
    id: ID!
    transfer: NativeTransfer
    account: Account!
    direction: TransferDirection
}

type NativeTransfer @entity {
    id: ID!
    blockNumber: Int! @index
    timestamp: DateTime! @index
    extrinsicHash: String @index
    from: Account!
    to: Account!
    amount: BigInt! @index
    success: Boolean!
}

type IdentityAdditionalField {
    name: String
    value: String
}

enum Judgement {
    Unknown
    FeePaid
    Reasonable
    KnownGood
    OutOfDate
    LowQuality
    Erroneous
}

type Identity @entity {
    id: ID!
    account: Account! @unique
    judgement: Judgement!
    subs: [SubIdentity!] @derivedFrom(field: "super")
    additional: [IdentityAdditionalField!]
    display: String
    legal: String
    web: String
    riot: String
    email: String
    pgpFingerprint: String
    image: String
    twitter: String
    isKilled: Boolean!
}

type IdentitySub @entity {
    id: ID!
    super: Identity
    account: Account! @unique
    name: String
}

enum BondType {
    Bond
    Unbond
    Reward
}

type StakingReward @entity {
    id: ID!
    timestamp: DateTime!
    blockNumber: Int! @index
    extrinsicHash: String @index
    account: Account!
    amount: BigInt!
    era: Int
    validatorId: ID
    validator: EraValidator
    staker: Staker!
}

type StakingBond @entity {
    id: ID!
    timestamp: DateTime!
    blockNumber: Int! @index
    extrinsicHash: String @index
    account: Account!
    amount: BigInt!
    type: BondType!
    staker: Staker!
}

enum StakingRole {
    Validator
    Nominator
    Idle
    Unknown
}

type ValidatorData {
    commission: Float!
    blocked: Boolean!
}

type NominatorData {
    targets: [String!]!
}

union StakingData = ValidatorData | NominatorData

enum PayeeType {
    Staked
    Stash
    Controller
    Account
    None
    Unknown
}

type Staker @entity {
    id: ID! #stash Id
    stash: Account! @unique
    controller: Account

    payeeType: PayeeType!
    payee: Account

    activeBond: BigInt!
    totalReward: BigInt!
    # totalSlash: BigInt!

    role: StakingRole!
    data: StakingData

    # history: [EraStaker!] @derivedFrom(field: "staker")
    rewards: [StakingReward!] @derivedFrom(field: "staker")
    # slashes: [Slash!] @derivedFrom(field: "staker")
    bonds: [StakingBond!] @derivedFrom(field: "staker")
}

type Era @entity {
    id: ID!
    index: Int!
    timestamp: DateTime!
    startedAt: Int!
    endedAt: Int
    total: BigInt!
    validatorsCount: Int!
    nominatorsCount: Int!
    # stakers: [EraStaker] @derivedFrom(field: "era")
}

interface EraStaker @query {
    id: ID! #era + stashId
    staker: Staker!
    era: Era!
    bonded: BigInt!
    eraReward: BigInt!
    # eraSlash: BigInt!
}

type EraValidator implements EraStaker @entity {
    id: ID! #era + stashId
    staker: Staker!
    era: Era!
    bonded: BigInt!
    totalBonded: BigInt!
    eraReward: BigInt!
    # eraSlash: BigInt!
    commission: Int
    nominators: [EraNomination!] @derivedFrom(field: "validator")
}

type EraNominator implements EraStaker @entity {
    id: ID! #era + stashId
    staker: Staker!
    era: Era!
    bonded: BigInt!
    eraReward: BigInt!
    # eraSlash: BigInt!
    validators: [EraNomination!] @derivedFrom(field: "nominator")
}

type EraNomination @entity {
    id: ID! #era + validatorId + nominatorId
    era: Era!
    nominator: EraNominator!
    validator: EraValidator!
    vote: BigInt!
}
