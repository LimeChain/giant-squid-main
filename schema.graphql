# This is an auto-generated file used by the graphiQL explorer to define the tables and relationships between them.
# This file will be auto-populated based on the pallets used in src/chain/{chainName}/main.ts
# See generateSchema.ts for more information on how this file is generated.

enum ParachainStatus {
  Reserved
  Registered
  Deregistered
  Parachain
  Parathread
  Dissolved
}

type Parachain @entity {
  id: ID! # para id
  manager: Account!

  status: ParachainStatus!

  crowdloans: [Crowdloan!] @derivedFrom(field: "parachain")
}

type CrowdloanContributor @entity {
  id: ID! # account id + crowdloan id
  account: Account!

  totalContributed: BigInt!
  reimbursed: Boolean!

  crowdloan: Crowdloan!
  contributions: [CrowdloanContribution!] @derivedFrom(field: "contributor")
  reimbursements: [CrowdloanReimbursement!] @derivedFrom(field: "contributor")

  timestamp: DateTime!
  blockNumber: Int! @index
}

type CrowdloanContribution @entity {
  id: ID!
  crowdloan: Crowdloan!
  contributor: CrowdloanContributor!
  amount: BigInt!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
}

enum CrowdloanReimbursementType {
  Refund
  Withdraw
}

type CrowdloanReimbursement @entity {
  id: ID! # contributor id
  crowdloan: Crowdloan!
  contributor: CrowdloanContributor!
  type: CrowdloanReimbursementType!
  amount: BigInt!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
}

enum CrowdloanStatus {
  Active
  Dissolved
}

type Crowdloan @entity {
  id: ID!
  parachain: Parachain!

  status: CrowdloanStatus!
  raised: BigInt!
  reimbursed: BigInt!

  contributions: [CrowdloanContribution!] @derivedFrom(field: "crowdloan")
  reimbursements: [CrowdloanReimbursement!] @derivedFrom(field: "crowdloan")

  cap: BigInt!
  leasePeriodStart: Int!
  leasePeriodEnd: Int!
  endBlock: Int!
  startBlock: Int! @index
}

type IdentityAdditionalField {
  name: String
  value: String
}

enum Judgement {
  Unknown
  FeePaid
  Reasonable
  KnownGood
  OutOfDate
  LowQuality
  Erroneous
}

type Identity @entity {
  id: ID!
  account: Account! @unique
  judgement: Judgement!
  subs: [IdentitySub!] @derivedFrom(field: "super")
  additional: [IdentityAdditionalField!]
  display: String
  legal: String
  web: String
  riot: String
  email: String
  pgpFingerprint: String
  image: String
  twitter: String
  isKilled: Boolean!
}

type IdentitySub @entity {
  id: ID!
  super: Identity
  account: Account! @unique
  name: String
}

type Staker @entity {
  id: ID! #stash Id
  stash: Account! @unique
  controller: Account

  payee: StakingPayee

  activeBonded: BigInt!
  totalBonded: BigInt!
  totalUnbonded: BigInt!
  totalWithdrawn: BigInt!
  totalSlashed: BigInt!
  totalRewarded: BigInt!

  payees: [StakingPayee] @derivedFrom(field: "staker")
  unlockings: [StakingUnlockChunk!] @derivedFrom(field: "staker")
}

enum RewardDestination {
  Staked
  Stash
  Controller
  Account
  None
}

type StakingPayee @entity {
  id: ID!
  staker: Staker!
  account: Account
  type: RewardDestination!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
}

type StakingUnlockChunk @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  staker: Staker!
  lockedUntilEra: Int!
  amount: BigInt!
  withdrawn: Boolean!
}

type StakingReward @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  amount: BigInt!
  staker: Staker!
  era: Int
  validatorId: ID
}

type ParachainStakingReward @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  amount: BigInt!
}

type ParachainStakingCompound @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  delegator: Account!
  amount: BigInt!
}

type ParachainStakingDelegation @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  delegator: Account!
  amount: BigInt!
  delegatorPosition: String
  autoCompundPercent: Int!
}

type ParachainStakingDelegationRevoked @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  delegator: Account!
  amount: BigInt!
}

type ParachainStakingDelegationIncreased @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  delegator: Account!
  amount: BigInt!
}

type ParachainStakingDelegationDecreased @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  delegator: Account!
  amount: BigInt!
}

type ParachainStakingDelegationKicked @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  delegator: Account!
  amount: BigInt!
}

type ParachainStakingCandidatesWithdrawed @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  amount: BigInt!
}

type ParachainStakingCandidatesBonded @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  amount: BigInt!
}

type ParachainStakingCandidatesUnbonded @entity {
  id: ID!
  timestamp: DateTime!
  blockNumber: Int! @index
  extrinsicHash: String @index
  account: Account!
  staker: Staker!
  amount: BigInt!
}

enum PolkadotXcmTransferCall {
  LimitedReserveTransferAssets
  LimitedTeleportAssets
  ReserveTransferAssets
  TransferAssetsUsingTypeAndThen
  TransferAssets
}

type PolkadotXcmTransfer @entity {
  id: ID!
  blockNumber: Int! @index
  timestamp: DateTime! @index
  extrinsicHash: String @index
  feeAssetItem: Int! @index
  account: Account!
  to: String!
  toChain: String! @index
  amount: BigInt!
  weightLimit: BigInt
  call: PolkadotXcmTransferCall!
}

type QueryLogs @entity {
  id: ID!
  query: String!
  timestamp: DateTime!
  location: String
  chainName: String!
}

enum TransferDirection {
  From
  To
}

# entity for linking account and transfer
type Transfer @entity {
  id: ID!
  transfer: NativeTransfer
  account: Account!
  direction: TransferDirection
}

type NativeTransfer @entity {
  id: ID!
  blockNumber: Int! @index
  timestamp: DateTime! @index
  extrinsicHash: String @index
  from: Account!
  to: Account!
  amount: BigInt! @index
  success: Boolean!
}

enum XcmTransferCall {
  LimitedReserveTransferAssets
  LimitedTeleportAssets
  ReserveTransferAssets
  TransferAssetsUsingTypeAndThen
  TransferAssets
}

type XcmTransfer @entity {
  id: ID!
  blockNumber: Int! @index
  timestamp: DateTime! @index
  extrinsicHash: String @index
  feeAssetItem: Int! @index
  account: Account!
  to: String!
  toChain: Parachain
  amount: BigInt!
  weightLimit: BigInt
  call: XcmTransferCall!
}

type Account @entity {
  id: ID!
  publicKey: ID! @index
  transfers: [Transfer!] @derivedFrom(field: "account")
  sub: IdentitySub @derivedFrom(field: "account")
  identity: Identity @derivedFrom(field: "account")
  staker: Staker @derivedFrom(field: "stash")
  rewards: [StakingReward!] @derivedFrom(field: "account")
  xcmTransfers: [XcmTransfer!] @derivedFrom(field: "account")
  polkadotXcmTransfers: [PolkadotXcmTransfer!] @derivedFrom(field: "account")
}
